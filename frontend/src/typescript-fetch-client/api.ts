/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * KICKERCUP REST API
 * REST-API for KICKERCUP REST API
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

// Put API Base URL here
export const BASE_PATH = "http://localhost:8080".replace(/\/+$/, "");


/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration!: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name!: "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface ApplicationContext
 */
export interface ApplicationContext {
  /**
   *
   * @type {string}
   * @memberof ApplicationContext
   */
  applicationName?: string;
  /**
   *
   * @type {AutowireCapableBeanFactory}
   * @memberof ApplicationContext
   */
  autowireCapableBeanFactory?: AutowireCapableBeanFactory;
  /**
   *
   * @type {number}
   * @memberof ApplicationContext
   */
  beanDefinitionCount?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ApplicationContext
   */
  beanDefinitionNames?: Array<string>;
  /**
   *
   * @type {ClassLoader}
   * @memberof ApplicationContext
   */
  classLoader?: ClassLoader;
  /**
   *
   * @type {string}
   * @memberof ApplicationContext
   */
  displayName?: string;
  /**
   *
   * @type {Environment}
   * @memberof ApplicationContext
   */
  environment?: Environment;
  /**
   *
   * @type {string}
   * @memberof ApplicationContext
   */
  id?: string;
  /**
   *
   * @type {ApplicationContext}
   * @memberof ApplicationContext
   */
  parent?: ApplicationContext;
  /**
   *
   * @type {BeanFactory}
   * @memberof ApplicationContext
   */
  parentBeanFactory?: BeanFactory;
  /**
   *
   * @type {number}
   * @memberof ApplicationContext
   */
  startupDate?: number;
}

/**
 *
 * @export
 * @interface AutowireCapableBeanFactory
 */
export interface AutowireCapableBeanFactory {}

/**
 *
 * @export
 * @interface BeanFactory
 */
export interface BeanFactory {}

/**
 *
 * @export
 * @interface ClassLoader
 */
export interface ClassLoader {
  /**
   *
   * @type {ClassLoader}
   * @memberof ClassLoader
   */
  parent?: ClassLoader;
}

/**
 *
 * @export
 * @interface Design
 */
export interface Design {
  /**
   *
   * @type {number}
   * @memberof Design
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Design
   */
  primaryColor?: string;
  /**
   *
   * @type {string}
   * @memberof Design
   */
  secondaryColor?: string;
}

/**
 *
 * @export
 * @interface Environment
 */
export interface Environment {
  /**
   *
   * @type {Array<string>}
   * @memberof Environment
   */
  activeProfiles?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Environment
   */
  defaultProfiles?: Array<string>;
}

/**
 *
 * @export
 * @interface Match
 */
export interface Match {
  /**
   *
   * @type {boolean}
   * @memberof Match
   */
  finished?: boolean;
  /**
   *
   * @type {number}
   * @memberof Match
   */
  goalsGuest?: number;
  /**
   *
   * @type {number}
   * @memberof Match
   */
  goalsHome?: number;
  /**
   *
   * @type {number}
   * @memberof Match
   */
  id?: number;
  /**
   *
   * @type {Team}
   * @memberof Match
   */
  teamGuest?: Team;
  /**
   *
   * @type {Team}
   * @memberof Match
   */
  teamHome?: Team;
}

/**
 *
 * @export
 * @interface Player
 */
export interface Player {
  /**
   *
   * @type {string}
   * @memberof Player
   */
  emailId?: string;
  /**
   *
   * @type {string}
   * @memberof Player
   */
  firstName?: string;
  /**
   *
   * @type {number}
   * @memberof Player
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof Player
   */
  lastName?: string;
  /**
   *
   * @type {number}
   * @memberof Player
   */
  rankScore?: number;
}

/**
 *
 * @export
 * @interface RedirectView
 */
export interface RedirectView {
  /**
   *
   * @type {ApplicationContext}
   * @memberof RedirectView
   */
  applicationContext?: ApplicationContext;
  /**
   *
   * @type {any}
   * @memberof RedirectView
   */
  attributesMap?: any;
  /**
   *
   * @type {string}
   * @memberof RedirectView
   */
  beanName?: string;
  /**
   *
   * @type {string}
   * @memberof RedirectView
   */
  contentType?: string;
  /**
   *
   * @type {boolean}
   * @memberof RedirectView
   */
  exposePathVariables?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof RedirectView
   */
  hosts?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof RedirectView
   */
  propagateQueryProperties?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof RedirectView
   */
  redirectView?: boolean;
  /**
   *
   * @type {string}
   * @memberof RedirectView
   */
  requestContextAttribute?: string;
  /**
   *
   * @type {any}
   * @memberof RedirectView
   */
  staticAttributes?: any;
  /**
   *
   * @type {string}
   * @memberof RedirectView
   */
  url?: string;
}

/**
 *
 * @export
 * @interface Statistic
 */
export interface Statistic {
  /**
   *
   * @type {number}
   * @memberof Statistic
   */
  goalsCount?: number;
  /**
   *
   * @type {number}
   * @memberof Statistic
   */
  matchCount?: number;
  /**
   *
   * @type {Array<Player>}
   * @memberof Statistic
   */
  players?: Array<Player>;
  /**
   *
   * @type {number}
   * @memberof Statistic
   */
  playersCount?: number;
  /**
   *
   * @type {number}
   * @memberof Statistic
   */
  tournamentCount?: number;
}

/**
 *
 * @export
 * @interface Team
 */
export interface Team {
  /**
   *
   * @type {number}
   * @memberof Team
   */
  id?: number;
  /**
   *
   * @type {Player}
   * @memberof Team
   */
  playerLeft?: Player;
  /**
   *
   * @type {Player}
   * @memberof Team
   */
  playerRight?: Player;
}

/**
 *
 * @export
 * @interface Tournament
 */
export interface Tournament {
  /**
   *
   * @type {number}
   * @memberof Tournament
   */
  amountGoals?: number;
  /**
   *
   * @type {number}
   * @memberof Tournament
   */
  amountSets?: number;
  /**
   *
   * @type {string}
   * @memberof Tournament
   */
  gamemode?: Tournament.GamemodeEnum;
  /**
   *
   * @type {number}
   * @memberof Tournament
   */
  id?: number;
  /**
   *
   * @type {boolean}
   * @memberof Tournament
   */
  isFinished?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Tournament
   */
  isRanked?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Tournament
   */
  isStarted?: boolean;
  /**
   *
   * @type {string}
   * @memberof Tournament
   */
  name?: string;
  /**
   *
   * @type {User}
   * @memberof Tournament
   */
  user?: User;
}

/**
 * @export
 * @namespace Tournament
 */
export namespace Tournament {
  /**
   * @export
   * @enum {string}
   */
  export enum GamemodeEnum {
    DoubleElimination = <any>"DoubleElimination",
    RankedSoloMatch = <any>"RankedSoloMatch",
    RankedTeamMatch = <any>"RankedTeamMatch",
    SingleKO = <any>"SingleKO"
  }
}

/**
 *
 * @export
 * @interface TournamentResult
 */
export interface TournamentResult {
  /**
   *
   * @type {string}
   * @memberof TournamentResult
   */
  header?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TournamentResult
   */
  subHeaders?: Array<string>;
  /**
   *
   * @type {TournamentResultTable}
   * @memberof TournamentResult
   */
  table?: TournamentResultTable;
}

/**
 *
 * @export
 * @interface TournamentResultTable
 */
export interface TournamentResultTable {
  /**
   *
   * @type {Array<string>}
   * @memberof TournamentResultTable
   */
  columnHeaders?: Array<string>;
  /**
   *
   * @type {Array<TournamentTableEntry>}
   * @memberof TournamentResultTable
   */
  entries?: Array<TournamentTableEntry>;
}

/**
 *
 * @export
 * @interface TournamentTableEntry
 */
export interface TournamentTableEntry {
  /**
   *
   * @type {number}
   * @memberof TournamentTableEntry
   */
  counterGoals?: number;
  /**
   *
   * @type {number}
   * @memberof TournamentTableEntry
   */
  goalsScored?: number;
  /**
   *
   * @type {number}
   * @memberof TournamentTableEntry
   */
  place?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof TournamentTableEntry
   */
  players?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof TournamentTableEntry
   */
  wins?: number;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName?: string;
  /**
   *
   * @type {number}
   * @memberof User
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username?: string;
}

/**
 * DesignControllerApi - fetch parameter creator
 * @export
 */
export const DesignControllerApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary ListByUser
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listByUserUsingGET(userId: number, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling listByUserUsingGET."
        );
      }
      const localVarPath = `/api/v1/users/{userId}/designs`.replace(
        `{${"userId"}}`,
        encodeURIComponent(String(userId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Update
     * @param {Design} design design
     * @param {number} id id
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUsingPUT(
      design: Design,
      id: number,
      userId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'design' is not null or undefined
      if (design === null || design === undefined) {
        throw new RequiredError(
          "design",
          "Required parameter design was null or undefined when calling updateUsingPUT."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling updateUsingPUT."
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling updateUsingPUT."
        );
      }
      const localVarPath = `/api/v1/users/{userId}/designs/{id}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Design" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(design || {})
        : design || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * DesignControllerApi - functional programming interface
 * @export
 */
export const DesignControllerApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary ListByUser
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listByUserUsingGET(
      userId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Design> {
      const localVarFetchArgs = DesignControllerApiFetchParamCreator(
        configuration
      ).listByUserUsingGET(userId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update
     * @param {Design} design design
     * @param {number} id id
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUsingPUT(
      design: Design,
      id: number,
      userId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Design> {
      const localVarFetchArgs = DesignControllerApiFetchParamCreator(
        configuration
      ).updateUsingPUT(design, id, userId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * DesignControllerApi - factory interface
 * @export
 */
export const DesignControllerApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary ListByUser
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listByUserUsingGET(userId: number, options?: any) {
      return DesignControllerApiFp(configuration).listByUserUsingGET(
        userId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update
     * @param {Design} design design
     * @param {number} id id
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUsingPUT(design: Design, id: number, userId: number, options?: any) {
      return DesignControllerApiFp(configuration).updateUsingPUT(
        design,
        id,
        userId,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * DesignControllerApi - object-oriented interface
 * @export
 * @class DesignControllerApi
 * @extends {BaseAPI}
 */
export class DesignControllerApi extends BaseAPI {
  /**
   *
   * @summary ListByUser
   * @param {number} userId userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DesignControllerApi
   */
  public listByUserUsingGET(userId: number, options?: any) {
    return DesignControllerApiFp(this.configuration).listByUserUsingGET(
      userId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update
   * @param {Design} design design
   * @param {number} id id
   * @param {number} userId userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DesignControllerApi
   */
  public updateUsingPUT(
    design: Design,
    id: number,
    userId: number,
    options?: any
  ) {
    return DesignControllerApiFp(this.configuration).updateUsingPUT(
      design,
      id,
      userId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * MatchControllerApi - fetch parameter creator
 * @export
 */
export const MatchControllerApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary addTeams
     * @param {number} matchId matchId
     * @param {number} teamGuestId teamGuestId
     * @param {number} teamHomeId teamHomeId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTeamsUsingPOST(
      matchId: number,
      teamGuestId: number,
      teamHomeId: number,
      tournamentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'matchId' is not null or undefined
      if (matchId === null || matchId === undefined) {
        throw new RequiredError(
          "matchId",
          "Required parameter matchId was null or undefined when calling addTeamsUsingPOST."
        );
      }
      // verify required parameter 'teamGuestId' is not null or undefined
      if (teamGuestId === null || teamGuestId === undefined) {
        throw new RequiredError(
          "teamGuestId",
          "Required parameter teamGuestId was null or undefined when calling addTeamsUsingPOST."
        );
      }
      // verify required parameter 'teamHomeId' is not null or undefined
      if (teamHomeId === null || teamHomeId === undefined) {
        throw new RequiredError(
          "teamHomeId",
          "Required parameter teamHomeId was null or undefined when calling addTeamsUsingPOST."
        );
      }
      // verify required parameter 'tournamentId' is not null or undefined
      if (tournamentId === null || tournamentId === undefined) {
        throw new RequiredError(
          "tournamentId",
          "Required parameter tournamentId was null or undefined when calling addTeamsUsingPOST."
        );
      }
      const localVarPath = `/api/v1/tournaments/{tournamentId}/matches/{matchId}/teams`
        .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)))
        .replace(
          `{${"tournamentId"}}`,
          encodeURIComponent(String(tournamentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (teamGuestId !== undefined) {
        localVarQueryParameter["teamGuestId"] = teamGuestId;
      }

      if (teamHomeId !== undefined) {
        localVarQueryParameter["teamHomeId"] = teamHomeId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary createMatch
     * @param {Match} match match
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMatchUsingPOST(
      match: Match,
      tournamentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'match' is not null or undefined
      if (match === null || match === undefined) {
        throw new RequiredError(
          "match",
          "Required parameter match was null or undefined when calling createMatchUsingPOST."
        );
      }
      // verify required parameter 'tournamentId' is not null or undefined
      if (tournamentId === null || tournamentId === undefined) {
        throw new RequiredError(
          "tournamentId",
          "Required parameter tournamentId was null or undefined when calling createMatchUsingPOST."
        );
      }
      const localVarPath = `/api/v1/tournaments/{tournamentId}/matches`.replace(
        `{${"tournamentId"}}`,
        encodeURIComponent(String(tournamentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Match" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(match || {})
        : match || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary deleteMatch
     * @param {number} matchId matchId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMatchUsingDELETE(
      matchId: number,
      tournamentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'matchId' is not null or undefined
      if (matchId === null || matchId === undefined) {
        throw new RequiredError(
          "matchId",
          "Required parameter matchId was null or undefined when calling deleteMatchUsingDELETE."
        );
      }
      // verify required parameter 'tournamentId' is not null or undefined
      if (tournamentId === null || tournamentId === undefined) {
        throw new RequiredError(
          "tournamentId",
          "Required parameter tournamentId was null or undefined when calling deleteMatchUsingDELETE."
        );
      }
      const localVarPath = `/api/v1/tournaments/{tournamentId}/matches/{matchId}`
        .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)))
        .replace(
          `{${"tournamentId"}}`,
          encodeURIComponent(String(tournamentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getAllMatches
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllMatchesUsingGET(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getAllMatchesUsingGET."
        );
      }
      const localVarPath = `/api/v1/tournaments/{id}/matches`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getMatchByTournamentIdAndMatchId
     * @param {number} matchId matchId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMatchByTournamentIdAndMatchIdUsingGET(
      matchId: number,
      tournamentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'matchId' is not null or undefined
      if (matchId === null || matchId === undefined) {
        throw new RequiredError(
          "matchId",
          "Required parameter matchId was null or undefined when calling getMatchByTournamentIdAndMatchIdUsingGET."
        );
      }
      // verify required parameter 'tournamentId' is not null or undefined
      if (tournamentId === null || tournamentId === undefined) {
        throw new RequiredError(
          "tournamentId",
          "Required parameter tournamentId was null or undefined when calling getMatchByTournamentIdAndMatchIdUsingGET."
        );
      }
      const localVarPath = `/api/v1/tournaments/{tournamentId}/matches/{matchId}`
        .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)))
        .replace(
          `{${"tournamentId"}}`,
          encodeURIComponent(String(tournamentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary updateMatch
     * @param {Match} matchDetails matchDetails
     * @param {number} matchId matchId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMatchUsingPUT(
      matchDetails: Match,
      matchId: number,
      tournamentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'matchDetails' is not null or undefined
      if (matchDetails === null || matchDetails === undefined) {
        throw new RequiredError(
          "matchDetails",
          "Required parameter matchDetails was null or undefined when calling updateMatchUsingPUT."
        );
      }
      // verify required parameter 'matchId' is not null or undefined
      if (matchId === null || matchId === undefined) {
        throw new RequiredError(
          "matchId",
          "Required parameter matchId was null or undefined when calling updateMatchUsingPUT."
        );
      }
      // verify required parameter 'tournamentId' is not null or undefined
      if (tournamentId === null || tournamentId === undefined) {
        throw new RequiredError(
          "tournamentId",
          "Required parameter tournamentId was null or undefined when calling updateMatchUsingPUT."
        );
      }
      const localVarPath = `/api/v1/tournaments/{tournamentId}/matches/{matchId}`
        .replace(`{${"matchId"}}`, encodeURIComponent(String(matchId)))
        .replace(
          `{${"tournamentId"}}`,
          encodeURIComponent(String(tournamentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Match" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(matchDetails || {})
        : matchDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * MatchControllerApi - functional programming interface
 * @export
 */
export const MatchControllerApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary addTeams
     * @param {number} matchId matchId
     * @param {number} teamGuestId teamGuestId
     * @param {number} teamHomeId teamHomeId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTeamsUsingPOST(
      matchId: number,
      teamGuestId: number,
      teamHomeId: number,
      tournamentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Match> {
      const localVarFetchArgs = MatchControllerApiFetchParamCreator(
        configuration
      ).addTeamsUsingPOST(
        matchId,
        teamGuestId,
        teamHomeId,
        tournamentId,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary createMatch
     * @param {Match} match match
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMatchUsingPOST(
      match: Match,
      tournamentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Match> {
      const localVarFetchArgs = MatchControllerApiFetchParamCreator(
        configuration
      ).createMatchUsingPOST(match, tournamentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary deleteMatch
     * @param {number} matchId matchId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMatchUsingDELETE(
      matchId: number,
      tournamentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<{ [key: string]: boolean }> {
      const localVarFetchArgs = MatchControllerApiFetchParamCreator(
        configuration
      ).deleteMatchUsingDELETE(matchId, tournamentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getAllMatches
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllMatchesUsingGET(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Match>> {
      const localVarFetchArgs = MatchControllerApiFetchParamCreator(
        configuration
      ).getAllMatchesUsingGET(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getMatchByTournamentIdAndMatchId
     * @param {number} matchId matchId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMatchByTournamentIdAndMatchIdUsingGET(
      matchId: number,
      tournamentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Match> {
      const localVarFetchArgs = MatchControllerApiFetchParamCreator(
        configuration
      ).getMatchByTournamentIdAndMatchIdUsingGET(
        matchId,
        tournamentId,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary updateMatch
     * @param {Match} matchDetails matchDetails
     * @param {number} matchId matchId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMatchUsingPUT(
      matchDetails: Match,
      matchId: number,
      tournamentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Match> {
      const localVarFetchArgs = MatchControllerApiFetchParamCreator(
        configuration
      ).updateMatchUsingPUT(matchDetails, matchId, tournamentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * MatchControllerApi - factory interface
 * @export
 */
export const MatchControllerApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary addTeams
     * @param {number} matchId matchId
     * @param {number} teamGuestId teamGuestId
     * @param {number} teamHomeId teamHomeId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTeamsUsingPOST(
      matchId: number,
      teamGuestId: number,
      teamHomeId: number,
      tournamentId: number,
      options?: any
    ) {
      return MatchControllerApiFp(configuration).addTeamsUsingPOST(
        matchId,
        teamGuestId,
        teamHomeId,
        tournamentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary createMatch
     * @param {Match} match match
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMatchUsingPOST(match: Match, tournamentId: number, options?: any) {
      return MatchControllerApiFp(configuration).createMatchUsingPOST(
        match,
        tournamentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary deleteMatch
     * @param {number} matchId matchId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMatchUsingDELETE(
      matchId: number,
      tournamentId: number,
      options?: any
    ) {
      return MatchControllerApiFp(configuration).deleteMatchUsingDELETE(
        matchId,
        tournamentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary getAllMatches
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllMatchesUsingGET(id: number, options?: any) {
      return MatchControllerApiFp(configuration).getAllMatchesUsingGET(
        id,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary getMatchByTournamentIdAndMatchId
     * @param {number} matchId matchId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMatchByTournamentIdAndMatchIdUsingGET(
      matchId: number,
      tournamentId: number,
      options?: any
    ) {
      return MatchControllerApiFp(
        configuration
      ).getMatchByTournamentIdAndMatchIdUsingGET(
        matchId,
        tournamentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary updateMatch
     * @param {Match} matchDetails matchDetails
     * @param {number} matchId matchId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMatchUsingPUT(
      matchDetails: Match,
      matchId: number,
      tournamentId: number,
      options?: any
    ) {
      return MatchControllerApiFp(configuration).updateMatchUsingPUT(
        matchDetails,
        matchId,
        tournamentId,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * MatchControllerApi - object-oriented interface
 * @export
 * @class MatchControllerApi
 * @extends {BaseAPI}
 */
export class MatchControllerApi extends BaseAPI {
  /**
   *
   * @summary addTeams
   * @param {number} matchId matchId
   * @param {number} teamGuestId teamGuestId
   * @param {number} teamHomeId teamHomeId
   * @param {number} tournamentId tournamentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MatchControllerApi
   */
  public addTeamsUsingPOST(
    matchId: number,
    teamGuestId: number,
    teamHomeId: number,
    tournamentId: number,
    options?: any
  ) {
    return MatchControllerApiFp(this.configuration).addTeamsUsingPOST(
      matchId,
      teamGuestId,
      teamHomeId,
      tournamentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary createMatch
   * @param {Match} match match
   * @param {number} tournamentId tournamentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MatchControllerApi
   */
  public createMatchUsingPOST(
    match: Match,
    tournamentId: number,
    options?: any
  ) {
    return MatchControllerApiFp(this.configuration).createMatchUsingPOST(
      match,
      tournamentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary deleteMatch
   * @param {number} matchId matchId
   * @param {number} tournamentId tournamentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MatchControllerApi
   */
  public deleteMatchUsingDELETE(
    matchId: number,
    tournamentId: number,
    options?: any
  ) {
    return MatchControllerApiFp(this.configuration).deleteMatchUsingDELETE(
      matchId,
      tournamentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getAllMatches
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MatchControllerApi
   */
  public getAllMatchesUsingGET(id: number, options?: any) {
    return MatchControllerApiFp(this.configuration).getAllMatchesUsingGET(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getMatchByTournamentIdAndMatchId
   * @param {number} matchId matchId
   * @param {number} tournamentId tournamentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MatchControllerApi
   */
  public getMatchByTournamentIdAndMatchIdUsingGET(
    matchId: number,
    tournamentId: number,
    options?: any
  ) {
    return MatchControllerApiFp(
      this.configuration
    ).getMatchByTournamentIdAndMatchIdUsingGET(
      matchId,
      tournamentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary updateMatch
   * @param {Match} matchDetails matchDetails
   * @param {number} matchId matchId
   * @param {number} tournamentId tournamentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MatchControllerApi
   */
  public updateMatchUsingPUT(
    matchDetails: Match,
    matchId: number,
    tournamentId: number,
    options?: any
  ) {
    return MatchControllerApiFp(this.configuration).updateMatchUsingPUT(
      matchDetails,
      matchId,
      tournamentId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * PlayerControllerApi - fetch parameter creator
 * @export
 */
export const PlayerControllerApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary createPlayer
     * @param {Player} player player
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPlayerUsingPOST(
      player: Player,
      userId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'player' is not null or undefined
      if (player === null || player === undefined) {
        throw new RequiredError(
          "player",
          "Required parameter player was null or undefined when calling createPlayerUsingPOST."
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling createPlayerUsingPOST."
        );
      }
      const localVarPath = `/api/v1/players`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Player" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(player || {})
        : player || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary deletePlayer
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePlayerUsingDELETE(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deletePlayerUsingDELETE."
        );
      }
      const localVarPath = `/api/v1/players/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getAllPlayers
     * @param {number} [userId] userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPlayersUsingGET(userId?: number, options: any = {}): FetchArgs {
      const localVarPath = `/api/v1/players`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getPlayerById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerByIdUsingGET(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getPlayerByIdUsingGET."
        );
      }
      const localVarPath = `/api/v1/players/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary updatePlayer
     * @param {Player} playerDetails PlayerDetails
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayerUsingPUT(
      playerDetails: Player,
      id: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'playerDetails' is not null or undefined
      if (playerDetails === null || playerDetails === undefined) {
        throw new RequiredError(
          "playerDetails",
          "Required parameter playerDetails was null or undefined when calling updatePlayerUsingPUT."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling updatePlayerUsingPUT."
        );
      }
      const localVarPath = `/api/v1/players/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Player" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(playerDetails || {})
        : playerDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * PlayerControllerApi - functional programming interface
 * @export
 */
export const PlayerControllerApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary createPlayer
     * @param {Player} player player
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPlayerUsingPOST(
      player: Player,
      userId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
      const localVarFetchArgs = PlayerControllerApiFetchParamCreator(
        configuration
      ).createPlayerUsingPOST(player, userId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary deletePlayer
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePlayerUsingDELETE(
      id: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<{ [key: string]: boolean }> {
      const localVarFetchArgs = PlayerControllerApiFetchParamCreator(
        configuration
      ).deletePlayerUsingDELETE(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getAllPlayers
     * @param {number} [userId] userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPlayersUsingGET(
      userId?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Player>> {
      const localVarFetchArgs = PlayerControllerApiFetchParamCreator(
        configuration
      ).getAllPlayersUsingGET(userId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getPlayerById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerByIdUsingGET(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
      const localVarFetchArgs = PlayerControllerApiFetchParamCreator(
        configuration
      ).getPlayerByIdUsingGET(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary updatePlayer
     * @param {Player} playerDetails PlayerDetails
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayerUsingPUT(
      playerDetails: Player,
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
      const localVarFetchArgs = PlayerControllerApiFetchParamCreator(
        configuration
      ).updatePlayerUsingPUT(playerDetails, id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * PlayerControllerApi - factory interface
 * @export
 */
export const PlayerControllerApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary createPlayer
     * @param {Player} player player
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPlayerUsingPOST(player: Player, userId: number, options?: any) {
      return PlayerControllerApiFp(configuration).createPlayerUsingPOST(
        player,
        userId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary deletePlayer
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePlayerUsingDELETE(id: number, options?: any) {
      return PlayerControllerApiFp(configuration).deletePlayerUsingDELETE(
        id,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary getAllPlayers
     * @param {number} [userId] userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPlayersUsingGET(userId?: number, options?: any) {
      return PlayerControllerApiFp(configuration).getAllPlayersUsingGET(
        userId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary getPlayerById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerByIdUsingGET(id: number, options?: any) {
      return PlayerControllerApiFp(configuration).getPlayerByIdUsingGET(
        id,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary updatePlayer
     * @param {Player} playerDetails PlayerDetails
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayerUsingPUT(playerDetails: Player, id: number, options?: any) {
      return PlayerControllerApiFp(configuration).updatePlayerUsingPUT(
        playerDetails,
        id,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * PlayerControllerApi - object-oriented interface
 * @export
 * @class PlayerControllerApi
 * @extends {BaseAPI}
 */
export class PlayerControllerApi extends BaseAPI {
  /**
   *
   * @summary createPlayer
   * @param {Player} player player
   * @param {number} userId userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerControllerApi
   */
  public createPlayerUsingPOST(player: Player, userId: number, options?: any) {
    return PlayerControllerApiFp(this.configuration).createPlayerUsingPOST(
      player,
      userId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary deletePlayer
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerControllerApi
   */
  public deletePlayerUsingDELETE(id: number, options?: any) {
    return PlayerControllerApiFp(this.configuration).deletePlayerUsingDELETE(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getAllPlayers
   * @param {number} [userId] userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerControllerApi
   */
  public getAllPlayersUsingGET(userId?: number, options?: any) {
    return PlayerControllerApiFp(this.configuration).getAllPlayersUsingGET(
      userId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getPlayerById
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerControllerApi
   */
  public getPlayerByIdUsingGET(id: number, options?: any) {
    return PlayerControllerApiFp(this.configuration).getPlayerByIdUsingGET(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary updatePlayer
   * @param {Player} playerDetails PlayerDetails
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerControllerApi
   */
  public updatePlayerUsingPUT(
    playerDetails: Player,
    id: number,
    options?: any
  ) {
    return PlayerControllerApiFp(this.configuration).updatePlayerUsingPUT(
      playerDetails,
      id,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * StatisticsControllerApi - fetch parameter creator
 * @export
 */
export const StatisticsControllerApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary getStats
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatsUsingGET(userId: number, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling getStatsUsingGET."
        );
      }
      const localVarPath = `/api/v1/statistics`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * StatisticsControllerApi - functional programming interface
 * @export
 */
export const StatisticsControllerApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary getStats
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatsUsingGET(
      userId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Statistic> {
      const localVarFetchArgs = StatisticsControllerApiFetchParamCreator(
        configuration
      ).getStatsUsingGET(userId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * StatisticsControllerApi - factory interface
 * @export
 */
export const StatisticsControllerApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary getStats
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatsUsingGET(userId: number, options?: any) {
      return StatisticsControllerApiFp(configuration).getStatsUsingGET(
        userId,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * StatisticsControllerApi - object-oriented interface
 * @export
 * @class StatisticsControllerApi
 * @extends {BaseAPI}
 */
export class StatisticsControllerApi extends BaseAPI {
  /**
   *
   * @summary getStats
   * @param {number} userId userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticsControllerApi
   */
  public getStatsUsingGET(userId: number, options?: any) {
    return StatisticsControllerApiFp(this.configuration).getStatsUsingGET(
      userId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * TeamControllerApi - fetch parameter creator
 * @export
 */
export const TeamControllerApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary addPlayers
     * @param {number} playerLeftId playerLeftId
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {number} [playerRightId] playerRightId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPlayersUsingPOST(
      playerLeftId: number,
      teamId: number,
      tournamentId: number,
      playerRightId?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'playerLeftId' is not null or undefined
      if (playerLeftId === null || playerLeftId === undefined) {
        throw new RequiredError(
          "playerLeftId",
          "Required parameter playerLeftId was null or undefined when calling addPlayersUsingPOST."
        );
      }
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          "teamId",
          "Required parameter teamId was null or undefined when calling addPlayersUsingPOST."
        );
      }
      // verify required parameter 'tournamentId' is not null or undefined
      if (tournamentId === null || tournamentId === undefined) {
        throw new RequiredError(
          "tournamentId",
          "Required parameter tournamentId was null or undefined when calling addPlayersUsingPOST."
        );
      }
      const localVarPath = `/api/v1/tournaments/{tournamentId}/teams/{teamId}/players`
        .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)))
        .replace(
          `{${"tournamentId"}}`,
          encodeURIComponent(String(tournamentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (playerLeftId !== undefined) {
        localVarQueryParameter["playerLeftId"] = playerLeftId;
      }

      if (playerRightId !== undefined) {
        localVarQueryParameter["playerRightId"] = playerRightId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary createTeam
     * @param {Team} team team
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTeamUsingPOST(
      team: Team,
      tournamentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'team' is not null or undefined
      if (team === null || team === undefined) {
        throw new RequiredError(
          "team",
          "Required parameter team was null or undefined when calling createTeamUsingPOST."
        );
      }
      // verify required parameter 'tournamentId' is not null or undefined
      if (tournamentId === null || tournamentId === undefined) {
        throw new RequiredError(
          "tournamentId",
          "Required parameter tournamentId was null or undefined when calling createTeamUsingPOST."
        );
      }
      const localVarPath = `/api/v1/tournaments/{tournamentId}/teams`.replace(
        `{${"tournamentId"}}`,
        encodeURIComponent(String(tournamentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Team" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(team || {})
        : team || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary deleteTeam
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTeamUsingDELETE(
      teamId: number,
      tournamentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          "teamId",
          "Required parameter teamId was null or undefined when calling deleteTeamUsingDELETE."
        );
      }
      // verify required parameter 'tournamentId' is not null or undefined
      if (tournamentId === null || tournamentId === undefined) {
        throw new RequiredError(
          "tournamentId",
          "Required parameter tournamentId was null or undefined when calling deleteTeamUsingDELETE."
        );
      }
      const localVarPath = `/api/v1/tournaments/{tournamentId}/teams/{teamId}`
        .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)))
        .replace(
          `{${"tournamentId"}}`,
          encodeURIComponent(String(tournamentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getAllTeams
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTeamsUsingGET(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getAllTeamsUsingGET."
        );
      }
      const localVarPath = `/api/v1/tournaments/{id}/teams`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getTeamByTournamentIdAndTeamId
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeamByTournamentIdAndTeamIdUsingGET(
      teamId: number,
      tournamentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          "teamId",
          "Required parameter teamId was null or undefined when calling getTeamByTournamentIdAndTeamIdUsingGET."
        );
      }
      // verify required parameter 'tournamentId' is not null or undefined
      if (tournamentId === null || tournamentId === undefined) {
        throw new RequiredError(
          "tournamentId",
          "Required parameter tournamentId was null or undefined when calling getTeamByTournamentIdAndTeamIdUsingGET."
        );
      }
      const localVarPath = `/api/v1/tournaments/{tournamentId}/teams/{teamId}`
        .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)))
        .replace(
          `{${"tournamentId"}}`,
          encodeURIComponent(String(tournamentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary updateTeam
     * @param {Team} teamDetails teamDetails
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTeamUsingPUT(
      teamDetails: Team,
      teamId: number,
      tournamentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'teamDetails' is not null or undefined
      if (teamDetails === null || teamDetails === undefined) {
        throw new RequiredError(
          "teamDetails",
          "Required parameter teamDetails was null or undefined when calling updateTeamUsingPUT."
        );
      }
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          "teamId",
          "Required parameter teamId was null or undefined when calling updateTeamUsingPUT."
        );
      }
      // verify required parameter 'tournamentId' is not null or undefined
      if (tournamentId === null || tournamentId === undefined) {
        throw new RequiredError(
          "tournamentId",
          "Required parameter tournamentId was null or undefined when calling updateTeamUsingPUT."
        );
      }
      const localVarPath = `/api/v1/tournaments/{tournamentId}/teams/{teamId}`
        .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)))
        .replace(
          `{${"tournamentId"}}`,
          encodeURIComponent(String(tournamentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Team" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(teamDetails || {})
        : teamDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * TeamControllerApi - functional programming interface
 * @export
 */
export const TeamControllerApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary addPlayers
     * @param {number} playerLeftId playerLeftId
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {number} [playerRightId] playerRightId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPlayersUsingPOST(
      playerLeftId: number,
      teamId: number,
      tournamentId: number,
      playerRightId?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
      const localVarFetchArgs = TeamControllerApiFetchParamCreator(
        configuration
      ).addPlayersUsingPOST(
        playerLeftId,
        teamId,
        tournamentId,
        playerRightId,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary createTeam
     * @param {Team} team team
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTeamUsingPOST(
      team: Team,
      tournamentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
      const localVarFetchArgs = TeamControllerApiFetchParamCreator(
        configuration
      ).createTeamUsingPOST(team, tournamentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary deleteTeam
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTeamUsingDELETE(
      teamId: number,
      tournamentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<{ [key: string]: boolean }> {
      const localVarFetchArgs = TeamControllerApiFetchParamCreator(
        configuration
      ).deleteTeamUsingDELETE(teamId, tournamentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getAllTeams
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTeamsUsingGET(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
      const localVarFetchArgs = TeamControllerApiFetchParamCreator(
        configuration
      ).getAllTeamsUsingGET(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getTeamByTournamentIdAndTeamId
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeamByTournamentIdAndTeamIdUsingGET(
      teamId: number,
      tournamentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
      const localVarFetchArgs = TeamControllerApiFetchParamCreator(
        configuration
      ).getTeamByTournamentIdAndTeamIdUsingGET(teamId, tournamentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary updateTeam
     * @param {Team} teamDetails teamDetails
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTeamUsingPUT(
      teamDetails: Team,
      teamId: number,
      tournamentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
      const localVarFetchArgs = TeamControllerApiFetchParamCreator(
        configuration
      ).updateTeamUsingPUT(teamDetails, teamId, tournamentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * TeamControllerApi - factory interface
 * @export
 */
export const TeamControllerApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary addPlayers
     * @param {number} playerLeftId playerLeftId
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {number} [playerRightId] playerRightId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPlayersUsingPOST(
      playerLeftId: number,
      teamId: number,
      tournamentId: number,
      playerRightId?: number,
      options?: any
    ) {
      return TeamControllerApiFp(configuration).addPlayersUsingPOST(
        playerLeftId,
        teamId,
        tournamentId,
        playerRightId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary createTeam
     * @param {Team} team team
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTeamUsingPOST(team: Team, tournamentId: number, options?: any) {
      return TeamControllerApiFp(configuration).createTeamUsingPOST(
        team,
        tournamentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary deleteTeam
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTeamUsingDELETE(teamId: number, tournamentId: number, options?: any) {
      return TeamControllerApiFp(configuration).deleteTeamUsingDELETE(
        teamId,
        tournamentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary getAllTeams
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTeamsUsingGET(id: number, options?: any) {
      return TeamControllerApiFp(configuration).getAllTeamsUsingGET(
        id,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary getTeamByTournamentIdAndTeamId
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTeamByTournamentIdAndTeamIdUsingGET(
      teamId: number,
      tournamentId: number,
      options?: any
    ) {
      return TeamControllerApiFp(
        configuration
      ).getTeamByTournamentIdAndTeamIdUsingGET(
        teamId,
        tournamentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary updateTeam
     * @param {Team} teamDetails teamDetails
     * @param {number} teamId teamId
     * @param {number} tournamentId tournamentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTeamUsingPUT(
      teamDetails: Team,
      teamId: number,
      tournamentId: number,
      options?: any
    ) {
      return TeamControllerApiFp(configuration).updateTeamUsingPUT(
        teamDetails,
        teamId,
        tournamentId,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * TeamControllerApi - object-oriented interface
 * @export
 * @class TeamControllerApi
 * @extends {BaseAPI}
 */
export class TeamControllerApi extends BaseAPI {
  /**
   *
   * @summary addPlayers
   * @param {number} playerLeftId playerLeftId
   * @param {number} teamId teamId
   * @param {number} tournamentId tournamentId
   * @param {number} [playerRightId] playerRightId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeamControllerApi
   */
  public addPlayersUsingPOST(
    playerLeftId: number,
    teamId: number,
    tournamentId: number,
    playerRightId?: number,
    options?: any
  ) {
    return TeamControllerApiFp(this.configuration).addPlayersUsingPOST(
      playerLeftId,
      teamId,
      tournamentId,
      playerRightId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary createTeam
   * @param {Team} team team
   * @param {number} tournamentId tournamentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeamControllerApi
   */
  public createTeamUsingPOST(team: Team, tournamentId: number, options?: any) {
    return TeamControllerApiFp(this.configuration).createTeamUsingPOST(
      team,
      tournamentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary deleteTeam
   * @param {number} teamId teamId
   * @param {number} tournamentId tournamentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeamControllerApi
   */
  public deleteTeamUsingDELETE(
    teamId: number,
    tournamentId: number,
    options?: any
  ) {
    return TeamControllerApiFp(this.configuration).deleteTeamUsingDELETE(
      teamId,
      tournamentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getAllTeams
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeamControllerApi
   */
  public getAllTeamsUsingGET(id: number, options?: any) {
    return TeamControllerApiFp(this.configuration).getAllTeamsUsingGET(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getTeamByTournamentIdAndTeamId
   * @param {number} teamId teamId
   * @param {number} tournamentId tournamentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeamControllerApi
   */
  public getTeamByTournamentIdAndTeamIdUsingGET(
    teamId: number,
    tournamentId: number,
    options?: any
  ) {
    return TeamControllerApiFp(
      this.configuration
    ).getTeamByTournamentIdAndTeamIdUsingGET(
      teamId,
      tournamentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary updateTeam
   * @param {Team} teamDetails teamDetails
   * @param {number} teamId teamId
   * @param {number} tournamentId tournamentId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeamControllerApi
   */
  public updateTeamUsingPUT(
    teamDetails: Team,
    teamId: number,
    tournamentId: number,
    options?: any
  ) {
    return TeamControllerApiFp(this.configuration).updateTeamUsingPUT(
      teamDetails,
      teamId,
      tournamentId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * TournamentControllerApi - fetch parameter creator
 * @export
 */
export const TournamentControllerApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary createTournament
     * @param {Tournament} tournament tournament
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTournamentUsingPOST(
      tournament: Tournament,
      userId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'tournament' is not null or undefined
      if (tournament === null || tournament === undefined) {
        throw new RequiredError(
          "tournament",
          "Required parameter tournament was null or undefined when calling createTournamentUsingPOST."
        );
      }
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling createTournamentUsingPOST."
        );
      }
      const localVarPath = `/api/v1/tournaments`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Tournament" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(tournament || {})
        : tournament || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary deleteTournament
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTournamentUsingDELETE(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteTournamentUsingDELETE."
        );
      }
      const localVarPath = `/api/v1/tournaments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getAllTournaments
     * @param {number} [userId] userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTournamentsUsingGET(userId?: number, options: any = {}): FetchArgs {
      const localVarPath = `/api/v1/tournaments`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getTournamentById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTournamentByIdUsingGET(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getTournamentByIdUsingGET."
        );
      }
      const localVarPath = `/api/v1/tournaments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getTournamentResultPDF
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTournamentResultPDFUsingGET(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getTournamentResultPDFUsingGET."
        );
      }
      const localVarPath = `/api/v1/tournaments/{id}/result/pdf`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getTournamentResult
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTournamentResultUsingGET(id: number, locale: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getTournamentResultUsingGET."
        );
      }
      const localVarPath = `/api/v1/tournaments/{id}/result`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
       );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (locale !== undefined) {
        localVarQueryParameter["locale"] = locale;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary teamMaking
     * @param {number} id id
     * @param {Array<Player>} playerListDetails playerListDetails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamMakingUsingPOST(
      id: number,
      playerListDetails: Array<Player>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling teamMakingUsingPOST."
        );
      }
      // verify required parameter 'playerListDetails' is not null or undefined
      if (playerListDetails === null || playerListDetails === undefined) {
        throw new RequiredError(
          "playerListDetails",
          "Required parameter playerListDetails was null or undefined when calling teamMakingUsingPOST."
        );
      }
      const localVarPath = `/api/v1/tournaments/{id}/teamMaking`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Array&lt;Player&gt;" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(playerListDetails || {})
        : playerListDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary updateTournament
     * @param {Tournament} tournamentDetails TournamentDetails
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTournamentUsingPUT(
      tournamentDetails: Tournament,
      id: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'tournamentDetails' is not null or undefined
      if (tournamentDetails === null || tournamentDetails === undefined) {
        throw new RequiredError(
          "tournamentDetails",
          "Required parameter tournamentDetails was null or undefined when calling updateTournamentUsingPUT."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling updateTournamentUsingPUT."
        );
      }
      const localVarPath = `/api/v1/tournaments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Tournament" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(tournamentDetails || {})
        : tournamentDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * TournamentControllerApi - functional programming interface
 * @export
 */
export const TournamentControllerApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary createTournament
     * @param {Tournament} tournament tournament
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTournamentUsingPOST(
      tournament: Tournament,
      userId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Tournament> {
      const localVarFetchArgs = TournamentControllerApiFetchParamCreator(
        configuration
      ).createTournamentUsingPOST(tournament, userId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary deleteTournament
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTournamentUsingDELETE(
      id: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<{ [key: string]: boolean }> {
      const localVarFetchArgs = TournamentControllerApiFetchParamCreator(
        configuration
      ).deleteTournamentUsingDELETE(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getAllTournaments
     * @param {number} [userId] userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTournamentsUsingGET(
      userId?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Tournament>> {
      const localVarFetchArgs = TournamentControllerApiFetchParamCreator(
        configuration
      ).getAllTournamentsUsingGET(userId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getTournamentById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTournamentByIdUsingGET(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Tournament> {
      const localVarFetchArgs = TournamentControllerApiFetchParamCreator(
        configuration
      ).getTournamentByIdUsingGET(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getTournamentResultPDF
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTournamentResultPDFUsingGET(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = TournamentControllerApiFetchParamCreator(
        configuration
      ).getTournamentResultPDFUsingGET(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getTournamentResult
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTournamentResultUsingGET(
      id: number,
      locale: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TournamentResult> {
      const localVarFetchArgs = TournamentControllerApiFetchParamCreator(
        configuration
      ).getTournamentResultUsingGET(id, locale, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary teamMaking
     * @param {number} id id
     * @param {Array<Player>} playerListDetails playerListDetails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamMakingUsingPOST(
      id: number,
      playerListDetails: Array<Player>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
      const localVarFetchArgs = TournamentControllerApiFetchParamCreator(
        configuration
      ).teamMakingUsingPOST(id, playerListDetails, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary updateTournament
     * @param {Tournament} tournamentDetails TournamentDetails
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTournamentUsingPUT(
      tournamentDetails: Tournament,
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Tournament> {
      const localVarFetchArgs = TournamentControllerApiFetchParamCreator(
        configuration
      ).updateTournamentUsingPUT(tournamentDetails, id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * TournamentControllerApi - factory interface
 * @export
 */
export const TournamentControllerApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary createTournament
     * @param {Tournament} tournament tournament
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTournamentUsingPOST(
      tournament: Tournament,
      userId: number,
      options?: any
    ) {
      return TournamentControllerApiFp(configuration).createTournamentUsingPOST(
        tournament,
        userId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary deleteTournament
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTournamentUsingDELETE(id: number, options?: any) {
      return TournamentControllerApiFp(
        configuration
      ).deleteTournamentUsingDELETE(id, options)(fetch, basePath);
    },
    /**
     *
     * @summary getAllTournaments
     * @param {number} [userId] userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTournamentsUsingGET(userId?: number, options?: any) {
      return TournamentControllerApiFp(configuration).getAllTournamentsUsingGET(
        userId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary getTournamentById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTournamentByIdUsingGET(id: number, options?: any) {
      return TournamentControllerApiFp(configuration).getTournamentByIdUsingGET(
        id,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary getTournamentResultPDF
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTournamentResultPDFUsingGET(id: number, options?: any) {
      return TournamentControllerApiFp(
        configuration
      ).getTournamentResultPDFUsingGET(id, options)(fetch, basePath);
    },
    /**
     *
     * @summary getTournamentResult
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTournamentResultUsingGET(id: number, options?: any) {
      return TournamentControllerApiFp(
        configuration
      ).getTournamentResultUsingGET(id, options)(fetch, basePath);
    },
    /**
     *
     * @summary teamMaking
     * @param {number} id id
     * @param {Array<Player>} playerListDetails playerListDetails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teamMakingUsingPOST(
      id: number,
      playerListDetails: Array<Player>,
      options?: any
    ) {
      return TournamentControllerApiFp(configuration).teamMakingUsingPOST(
        id,
        playerListDetails,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary updateTournament
     * @param {Tournament} tournamentDetails TournamentDetails
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTournamentUsingPUT(
      tournamentDetails: Tournament,
      id: number,
      options?: any
    ) {
      return TournamentControllerApiFp(configuration).updateTournamentUsingPUT(
        tournamentDetails,
        id,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * TournamentControllerApi - object-oriented interface
 * @export
 * @class TournamentControllerApi
 * @extends {BaseAPI}
 */
export class TournamentControllerApi extends BaseAPI {
  /**
   *
   * @summary createTournament
   * @param {Tournament} tournament tournament
   * @param {number} userId userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TournamentControllerApi
   */
  public createTournamentUsingPOST(
    tournament: Tournament,
    userId: number,
    options?: any
  ) {
    return TournamentControllerApiFp(
      this.configuration
    ).createTournamentUsingPOST(
      tournament,
      userId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary deleteTournament
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TournamentControllerApi
   */
  public deleteTournamentUsingDELETE(id: number, options?: any) {
    return TournamentControllerApiFp(
      this.configuration
    ).deleteTournamentUsingDELETE(id, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getAllTournaments
   * @param {number} [userId] userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TournamentControllerApi
   */
  public getAllTournamentsUsingGET(userId?: number, options?: any) {
    return TournamentControllerApiFp(
      this.configuration
    ).getAllTournamentsUsingGET(userId, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getTournamentById
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TournamentControllerApi
   */
  public getTournamentByIdUsingGET(id: number, options?: any) {
    return TournamentControllerApiFp(
      this.configuration
    ).getTournamentByIdUsingGET(id, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getTournamentResultPDF
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TournamentControllerApi
   */
  public getTournamentResultPDFUsingGET(id: number, options?: any) {
    return TournamentControllerApiFp(
      this.configuration
    ).getTournamentResultPDFUsingGET(id, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getTournamentResult
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TournamentControllerApi
   */
  public getTournamentResultUsingGET(id: number, locale: string, options?: any) {
    return TournamentControllerApiFp(
      this.configuration
    ).getTournamentResultUsingGET(id, locale, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary teamMaking
   * @param {number} id id
   * @param {Array<Player>} playerListDetails playerListDetails
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TournamentControllerApi
   */
  public teamMakingUsingPOST(
    id: number,
    playerListDetails: Array<Player>,
    options?: any
  ) {
    return TournamentControllerApiFp(this.configuration).teamMakingUsingPOST(
      id,
      playerListDetails,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary updateTournament
   * @param {Tournament} tournamentDetails TournamentDetails
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TournamentControllerApi
   */
  public updateTournamentUsingPUT(
    tournamentDetails: Tournament,
    id: number,
    options?: any
  ) {
    return TournamentControllerApiFp(
      this.configuration
    ).updateTournamentUsingPUT(
      tournamentDetails,
      id,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * TwitterControllerApi - fetch parameter creator
 * @export
 */
export const TwitterControllerApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary callback
     * @param {string} oauthVerifier oauth_verifier
     * @param {string} [oauthToken] oauth_token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callbackUsingGET(
      oauthVerifier: string,
      oauthToken?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'oauthVerifier' is not null or undefined
      if (oauthVerifier === null || oauthVerifier === undefined) {
        throw new RequiredError(
          "oauthVerifier",
          "Required parameter oauthVerifier was null or undefined when calling callbackUsingGET."
        );
      }
      const localVarPath = `/api/v1/twitter/callback`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (oauthToken !== undefined) {
        localVarQueryParameter["oauth_token"] = oauthToken;
      }

      if (oauthVerifier !== undefined) {
        localVarQueryParameter["oauth_verifier"] = oauthVerifier;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary replyFeedback
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replyFeedbackUsingGET(
      callbackUrl: string,
      message: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'callbackUrl' is not null or undefined
      if (callbackUrl === null || callbackUrl === undefined) {
        throw new RequiredError(
          "callbackUrl",
          "Required parameter callbackUrl was null or undefined when calling replyFeedbackUsingGET."
        );
      }
      // verify required parameter 'message' is not null or undefined
      if (message === null || message === undefined) {
        throw new RequiredError(
          "message",
          "Required parameter message was null or undefined when calling replyFeedbackUsingGET."
        );
      }
      const localVarPath = `/api/v1/twitter/reply/feedback`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (callbackUrl !== undefined) {
        localVarQueryParameter["callbackUrl"] = callbackUrl;
      }

      if (message !== undefined) {
        localVarQueryParameter["message"] = message;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary sendReply
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {string} recipient recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReplyUsingGET(
      callbackUrl: string,
      message: string,
      recipient: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'callbackUrl' is not null or undefined
      if (callbackUrl === null || callbackUrl === undefined) {
        throw new RequiredError(
          "callbackUrl",
          "Required parameter callbackUrl was null or undefined when calling sendReplyUsingGET."
        );
      }
      // verify required parameter 'message' is not null or undefined
      if (message === null || message === undefined) {
        throw new RequiredError(
          "message",
          "Required parameter message was null or undefined when calling sendReplyUsingGET."
        );
      }
      // verify required parameter 'recipient' is not null or undefined
      if (recipient === null || recipient === undefined) {
        throw new RequiredError(
          "recipient",
          "Required parameter recipient was null or undefined when calling sendReplyUsingGET."
        );
      }
      const localVarPath = `/api/v1/twitter/reply`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (callbackUrl !== undefined) {
        localVarQueryParameter["callbackUrl"] = callbackUrl;
      }

      if (message !== undefined) {
        localVarQueryParameter["message"] = message;
      }

      if (recipient !== undefined) {
        localVarQueryParameter["recipient"] = recipient;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary tweetFeedback
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetFeedbackUsingGET(
      callbackUrl: string,
      message: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'callbackUrl' is not null or undefined
      if (callbackUrl === null || callbackUrl === undefined) {
        throw new RequiredError(
          "callbackUrl",
          "Required parameter callbackUrl was null or undefined when calling tweetFeedbackUsingGET."
        );
      }
      // verify required parameter 'message' is not null or undefined
      if (message === null || message === undefined) {
        throw new RequiredError(
          "message",
          "Required parameter message was null or undefined when calling tweetFeedbackUsingGET."
        );
      }
      const localVarPath = `/api/v1/twitter/tweet/feedback`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (callbackUrl !== undefined) {
        localVarQueryParameter["callbackUrl"] = callbackUrl;
      }

      if (message !== undefined) {
        localVarQueryParameter["message"] = message;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary updateStatus
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStatusUsingGET(
      callbackUrl: string,
      message: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'callbackUrl' is not null or undefined
      if (callbackUrl === null || callbackUrl === undefined) {
        throw new RequiredError(
          "callbackUrl",
          "Required parameter callbackUrl was null or undefined when calling updateStatusUsingGET."
        );
      }
      // verify required parameter 'message' is not null or undefined
      if (message === null || message === undefined) {
        throw new RequiredError(
          "message",
          "Required parameter message was null or undefined when calling updateStatusUsingGET."
        );
      }
      const localVarPath = `/api/v1/twitter/tweet`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (callbackUrl !== undefined) {
        localVarQueryParameter["callbackUrl"] = callbackUrl;
      }

      if (message !== undefined) {
        localVarQueryParameter["message"] = message;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * TwitterControllerApi - functional programming interface
 * @export
 */
export const TwitterControllerApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary callback
     * @param {string} oauthVerifier oauth_verifier
     * @param {string} [oauthToken] oauth_token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callbackUsingGET(
      oauthVerifier: string,
      oauthToken?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RedirectView> {
      const localVarFetchArgs = TwitterControllerApiFetchParamCreator(
        configuration
      ).callbackUsingGET(oauthVerifier, oauthToken, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary replyFeedback
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replyFeedbackUsingGET(
      callbackUrl: string,
      message: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = TwitterControllerApiFetchParamCreator(
        configuration
      ).replyFeedbackUsingGET(callbackUrl, message, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary sendReply
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {string} recipient recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReplyUsingGET(
      callbackUrl: string,
      message: string,
      recipient: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = TwitterControllerApiFetchParamCreator(
        configuration
      ).sendReplyUsingGET(callbackUrl, message, recipient, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary tweetFeedback
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetFeedbackUsingGET(
      callbackUrl: string,
      message: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = TwitterControllerApiFetchParamCreator(
        configuration
      ).tweetFeedbackUsingGET(callbackUrl, message, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary updateStatus
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStatusUsingGET(
      callbackUrl: string,
      message: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = TwitterControllerApiFetchParamCreator(
        configuration
      ).updateStatusUsingGET(callbackUrl, message, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * TwitterControllerApi - factory interface
 * @export
 */
export const TwitterControllerApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary callback
     * @param {string} oauthVerifier oauth_verifier
     * @param {string} [oauthToken] oauth_token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callbackUsingGET(
      oauthVerifier: string,
      oauthToken?: string,
      options?: any
    ) {
      return TwitterControllerApiFp(configuration).callbackUsingGET(
        oauthVerifier,
        oauthToken,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary replyFeedback
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replyFeedbackUsingGET(callbackUrl: string, message: string, options?: any) {
      return TwitterControllerApiFp(configuration).replyFeedbackUsingGET(
        callbackUrl,
        message,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary sendReply
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {string} recipient recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReplyUsingGET(
      callbackUrl: string,
      message: string,
      recipient: string,
      options?: any
    ) {
      return TwitterControllerApiFp(configuration).sendReplyUsingGET(
        callbackUrl,
        message,
        recipient,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary tweetFeedback
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetFeedbackUsingGET(callbackUrl: string, message: string, options?: any) {
      return TwitterControllerApiFp(configuration).tweetFeedbackUsingGET(
        callbackUrl,
        message,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary updateStatus
     * @param {string} callbackUrl callbackUrl
     * @param {string} message message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStatusUsingGET(callbackUrl: string, message: string, options?: any) {
      return TwitterControllerApiFp(configuration).updateStatusUsingGET(
        callbackUrl,
        message,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * TwitterControllerApi - object-oriented interface
 * @export
 * @class TwitterControllerApi
 * @extends {BaseAPI}
 */
export class TwitterControllerApi extends BaseAPI {
  /**
   *
   * @summary callback
   * @param {string} oauthVerifier oauth_verifier
   * @param {string} [oauthToken] oauth_token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TwitterControllerApi
   */
  public callbackUsingGET(
    oauthVerifier: string,
    oauthToken?: string,
    options?: any
  ) {
    return TwitterControllerApiFp(this.configuration).callbackUsingGET(
      oauthVerifier,
      oauthToken,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary replyFeedback
   * @param {string} callbackUrl callbackUrl
   * @param {string} message message
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TwitterControllerApi
   */
  public replyFeedbackUsingGET(
    callbackUrl: string,
    message: string,
    options?: any
  ) {
    return TwitterControllerApiFp(this.configuration).replyFeedbackUsingGET(
      callbackUrl,
      message,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary sendReply
   * @param {string} callbackUrl callbackUrl
   * @param {string} message message
   * @param {string} recipient recipient
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TwitterControllerApi
   */
  public sendReplyUsingGET(
    callbackUrl: string,
    message: string,
    recipient: string,
    options?: any
  ) {
    return TwitterControllerApiFp(this.configuration).sendReplyUsingGET(
      callbackUrl,
      message,
      recipient,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary tweetFeedback
   * @param {string} callbackUrl callbackUrl
   * @param {string} message message
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TwitterControllerApi
   */
  public tweetFeedbackUsingGET(
    callbackUrl: string,
    message: string,
    options?: any
  ) {
    return TwitterControllerApiFp(this.configuration).tweetFeedbackUsingGET(
      callbackUrl,
      message,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary updateStatus
   * @param {string} callbackUrl callbackUrl
   * @param {string} message message
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TwitterControllerApi
   */
  public updateStatusUsingGET(
    callbackUrl: string,
    message: string,
    options?: any
  ) {
    return TwitterControllerApiFp(this.configuration).updateStatusUsingGET(
      callbackUrl,
      message,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * UserControllerApi - fetch parameter creator
 * @export
 */
export const UserControllerApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary authUser
     * @param {User} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserUsingPOST(user: User, options: any = {}): FetchArgs {
      // verify required parameter 'user' is not null or undefined
      if (user === null || user === undefined) {
        throw new RequiredError(
          "user",
          "Required parameter user was null or undefined when calling authUserUsingPOST."
        );
      }
      const localVarPath = `/api/v1/users/auth/`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"User" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(user || {})
        : user || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary createUser
     * @param {User} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserUsingPOST(user: User, options: any = {}): FetchArgs {
      // verify required parameter 'user' is not null or undefined
      if (user === null || user === undefined) {
        throw new RequiredError(
          "user",
          "Required parameter user was null or undefined when calling createUserUsingPOST."
        );
      }
      const localVarPath = `/api/v1/users`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"User" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(user || {})
        : user || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary deleteUser
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserUsingDELETE(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteUserUsingDELETE."
        );
      }
      const localVarPath = `/api/v1/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getAllUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersUsingGET(options: any = {}): FetchArgs {
      const localVarPath = `/api/v1/users`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary getUserById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByIdUsingGET(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getUserByIdUsingGET."
        );
      }
      const localVarPath = `/api/v1/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary updateUser
     * @param {User} userDetails UserDetails
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserUsingPUT(
      userDetails: User,
      id: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'userDetails' is not null or undefined
      if (userDetails === null || userDetails === undefined) {
        throw new RequiredError(
          "userDetails",
          "Required parameter userDetails was null or undefined when calling updateUserUsingPUT."
        );
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling updateUserUsingPUT."
        );
      }
      const localVarPath = `/api/v1/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"User" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(userDetails || {})
        : userDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary authUser
     * @param {User} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserUsingPOST(
      user: User,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).authUserUsingPOST(user, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary createUser
     * @param {User} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserUsingPOST(
      user: User,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).createUserUsingPOST(user, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary deleteUser
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserUsingDELETE(
      id: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<{ [key: string]: boolean }> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).deleteUserUsingDELETE(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getAllUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersUsingGET(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).getAllUsersUsingGET(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary getUserById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByIdUsingGET(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).getUserByIdUsingGET(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary updateUser
     * @param {User} userDetails UserDetails
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserUsingPUT(
      userDetails: User,
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).updateUserUsingPUT(userDetails, id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary authUser
     * @param {User} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserUsingPOST(user: User, options?: any) {
      return UserControllerApiFp(configuration).authUserUsingPOST(
        user,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary createUser
     * @param {User} user User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserUsingPOST(user: User, options?: any) {
      return UserControllerApiFp(configuration).createUserUsingPOST(
        user,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary deleteUser
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserUsingDELETE(id: number, options?: any) {
      return UserControllerApiFp(configuration).deleteUserUsingDELETE(
        id,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary getAllUsers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersUsingGET(options?: any) {
      return UserControllerApiFp(configuration).getAllUsersUsingGET(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary getUserById
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByIdUsingGET(id: number, options?: any) {
      return UserControllerApiFp(configuration).getUserByIdUsingGET(
        id,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary updateUser
     * @param {User} userDetails UserDetails
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserUsingPUT(userDetails: User, id: number, options?: any) {
      return UserControllerApiFp(configuration).updateUserUsingPUT(
        userDetails,
        id,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
  /**
   *
   * @summary authUser
   * @param {User} user User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public authUserUsingPOST(user: User, options?: any) {
    return UserControllerApiFp(this.configuration).authUserUsingPOST(
      user,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary createUser
   * @param {User} user User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public createUserUsingPOST(user: User, options?: any) {
    return UserControllerApiFp(this.configuration).createUserUsingPOST(
      user,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary deleteUser
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public deleteUserUsingDELETE(id: number, options?: any) {
    return UserControllerApiFp(this.configuration).deleteUserUsingDELETE(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary getAllUsers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public getAllUsersUsingGET(options?: any) {
    return UserControllerApiFp(this.configuration).getAllUsersUsingGET(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary getUserById
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public getUserByIdUsingGET(id: number, options?: any) {
    return UserControllerApiFp(this.configuration).getUserByIdUsingGET(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary updateUser
   * @param {User} userDetails UserDetails
   * @param {number} id id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public updateUserUsingPUT(userDetails: User, id: number, options?: any) {
    return UserControllerApiFp(this.configuration).updateUserUsingPUT(
      userDetails,
      id,
      options
    )(this.fetch, this.basePath);
  }
}
